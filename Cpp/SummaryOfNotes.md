博学之, 审问之, 慎思之, 明辨之, 笃行之;
零、壹、贰、叁、肆、伍、陆、柒、捌、玖、拾;






零.第一个Cpp程序 (helloworld)
    
    命令行gcc运行:
        指定输出:
            gcc -lstdc++ main.cpp -o test
                生成 test
            ./test
                输出： Hello World！
        不指定输出:
            gcc -lstdc++ main.cpp
                生成 a.out
            ./a.out
                输出： Hello World！
    CLion集成环境：
        Tools ==> CMake ==> Unload CMake Project
        这样会在 cpp 文件中自动提示 Create CMakeLists.txt
        点击它将自动在根目录生成 CMakeLists.txt 配置文件
    
    XCode集成环境：
        Create a new Xcode Project
        macos ==> Command Line Tool
        在项目构建窗口中自行配置项目信息，注意Language 选择 C++ 即可。
    
    后续都将用XCode集成环境进行学习
    
    
    
    
    
    

壹.命名&注释&变量&常量 (001designate&variable&Constant)
    
    数据是信息的载体,C程序大多时的目的就是为了处理数据.
    数据的分类:
        数字,字符,字符串三种类型:
        字符是单引号,字符串是双引号.
    
    输出数据:
        std::cout               输出各种类型的数据
        <<                      输出操作符,可以拼接多个数据项
        std::endl               也可以用于换行
        using namespace std;    指定缺省的命名空间
    
    注释:
        单行注释: //
        单行注释: /**/
        多行注释可以注释掉单行注释,单行注释也可以注释掉多行注释(牛逼,已经不认识释这个字了)
    
    变量:
        C++中常用的数据类型:
            整数(int)
            浮点数(float,double)
            字符(char)
            字符串(string)
            布尔(bool)
        注意: C++ 中ture输出是用1表示,false用0表示
    
    常量:
        宏常量:
            一般在main函数外面声明,用大写命名,注意宏常量结尾不需要分号
        const修饰的常量:
            在程序的任何地方都可以声明.
        常量值的特点即不能被修改.
    
    标识符的命名:
        C++规定给标识符命名时(变量,常量,函数,结构体,类等),必须遵守以下规则:
            字母,数字,下划线命名.
            命名首位不能是数字.
            命名大小写区分.
            不能以关键字进行命名.
            下划线和大写字母打头的名称,被保留个编译器和其使用的资源使用,可以这么用但是不推荐.因为C++会扩展,过几年就会有新的标准,下划线命名的名称现在不会和新标准冲突,
                并不表示以后也是合法的.所以最好别这么用.
    
    输入数据:
        程序输入数据的方式有多种:
            从控制台命令行的界面中输入.
            从文件中读取.
            从数据库中读取.
            从网络中读取.
        语法:
            std::cin                输入各种类型的数据
            >>                      输入操作符,可以拼接多个数据项
        注意:
            布尔型变量输入时只能填0和非0,非0将转换为1.
            如果命令行中输入的数据和程序中变量的数据类型不匹配.会导致行为的不确定性.
        
    







贰.算术运算 (002arithmetic)

    算术运算:
        整数如果除0,程序将异常退出.
        浮点数如果除0,将得到Inf(infinite)
        整数与浮点数进行除法运算时,得到的结果是浮点数
        进行除法运算时,在整数前面加(float)或(double)可以将整数转换为浮点数,这是强制类型转换的结果
        求余运算只能用于整数,且分母不能为0.
    
    自增和自减:
        ++a: 先把变量值加1, 然后再执行表达式.
        a++: 先执行表达式, 再把变量值加1.
        --a: 先把变量值减1, 然后再执行表达式.
        a--: 先执行表达式, 再把变量减1.
    
    赋值运算符:
        =
        +=
        -=
        *=
        /=
        %=
        
    C++11初始化赋值:
        C++ 标准:
            int h = 10;
            int j = (10);
            int k (10);
        
        C++11 标准:
            int h1 = 10;
            int j1 = {10};
            int k1 {10};
    
        注意: 在Linux平台下, 编译需要加 -std=c++11 参数, 否则会报错.

    关系运算:
        用于比较两个表达式的值, 运算的结果为1和0, 即 1-true 和 0-false.
        
        ==
        !=
        <
        <=
        >
        >=
        
       注意:
            std::cout输出关系运算表达式时, 关系表达式要加括号, 否则会报错.
    
    逻辑运算:
        &&
        ||
        !

    逗号运算:
        赋值运算符的结合律(顺序)是从右到左,如:(a = b = 10).
        算术运算的组合方式是从左到右,如:(a * b / c).
        括号优先级除数组下标外是最高的, 可以改变全部运算符的优先级.
        








叁.条件分支语句(003conditionStatement)
    
    经典 if else 语句:
        注意事项:
            if和else语句如果只是执行一行语句,那么可以不写花括号,如果是多行语句就不需要写花括号.
    
    三目运算:
        c = (a > b) ? a : b
        
    switch语句:
        注意每个case条件中不要漏掉 break, 如果使用 return 语句, 后面必须跟个值一般return 0即可.
    











肆.循环语句(004circulateStatement)

    while:
        while(express){
            statement;
        }
    
    循环的跳转:
        break
            跳出(终止)当前循环语句
        continue
            回到当前循环语句的首部
    for:
        for(int i = 0; i < 10; i++) {
            cout << "当前的值是: " << i << endl;
        }
    嵌套循环:
        99乘法表实现.
    do while:
        int a = 10;
        do{
            cout << a++ << endl;
        }while(a < 20);
        和while的区别: 无论条件是否成立都会首先执行一次.
    goto:
        goto语句也被称为无条件转移语句.
        语法:
            cout << "第1个程序员的编号" << endl;
            goto bbb;
            cout << "第2个程序员的编号" << endl;
            cout << "第3个程序员的编号" << endl;
            cout << "第4个程序员的编号" << endl;
            bbb: cout << "第5个程序员的编号" << endl;
        输出结果:
            第1个程序员的编号
            第5个程序员的编号
        建议:
            在实际开发中,goto语句很容易造成程序流程的混乱,对维护工作带来很大压力,所以几乎看到goto语句的应用,也不建议使用.
        










伍.函数基础(005fundamentalsOfFunc)
    
    函数声明:
        int maxNum(int a, int b);
    函数定义:
        int maxNum(int a, int b) {
            return a > b ? a : b;
        }
        注意:
            函数的定义和声明可以书写在一起, 如果在一起, 一般在main函数的上面, 如果分开, 一般在main函数上面声明, 在main函数下面定义
            一般开发中都是将它们分开书写, 声明是声明, 定义是定义.
            在同一个程序中, 函数只需要声明和定义一次, 也可以多次声明, 但只能定义一次;
            函数的声明必须和定义的一致(返回值类型,函数名,参数列表), 否则程序将认定他们不是同一个函数.
    函数调用:
        cout << "man(5,8) = " << maxNum(5,8) << endl;
        注意:
            如果函数的重点是实现功能, 不关心返回值, 返回值的数据类型为void, return后面直接分号结束即可.
            声明函数的代码必须放在调用之前, 定义函数的代码可以放在调用之后.
            main函数不能被调用
    变量的作用域:
        注意:
            变量分全局和局部两种, 在全部函数外部定义的是全局变量.
            在头文件中定义的是全局变量.
            在函数和语句块内部定义的是局部变量.
            函数参数就是该函数的一种局部变量.
            函数内部用static修饰的是静态局部变量,简称静态变量.
                静态变量拥有和程序相同的生命周期,并且只会被初始化一次.
                当程序想要使用全局变量时,可以根据场景考虑优先使用静态变量.
                如果在代码块内部的局部变量和全局变量重名了, 可以通过 :: 来指定使用全局变量.
            for循环初始化语句中定义的变量只作用于for循环的语句块.
    函数参数传递:
        实参:
        形参:
    函数分文件编写:
        函数分文件编写:
            头文件(*.h | *.hpp)
                需要包含的头文件, 指定命名空间, 声明全局变量, 函数的声明, 数据结构和类的声明等...
            源文件(*.c | *.cpp)
                函数的定义, 类的定义.
            主程序(main函数)
                程序的核心流程, 需要用 #include "头文件名" 把头文件包含进来.
        注意:
            #include "tools.h"
                包含自定义的头文件使用双引号
            #include <iostream>
                包含系统的头文件使用尖括号
        编译:
            mac是集成开发环境,不需要写入编译指令.
            linux系统下,把全部的源文件,一起编译,如: gcc -o main main.cpp tools.cpp funcs.cpp
    递归函数:
        int recursion(int x){
            if (x == 0) return 0;
            return x + recursion(x-1);
        };

        






    
陆.C++数据类型(006dataType)
    
    C++四种基本数据类型:
        整数(int)
        浮点数(float/double)
        字符(char)
        布尔(bool)
    
    sizeof
        sizeof运算符是用于求数据类型或变量占用的内存空间
        用于数据类型:
            sizeof(数据类型)
        用于变量:
            sizeof(变量名)
            sizeof 变量名
        注意:
            在32位和64位操作系统中,同一数据类型占用的内存空间可能不一样.
            字符串(string)不是c++的基本数据类型,是c++中的一个类,用sizeof求它占用内存的大小没有意义.
    
    整型的基本概念
        int 是 integer 的简写
        在声明整型变量时,可以在int之前加 signed, unsigned, short, long四种修饰符.
            signed: 有符号的,可以表示正数和负数
            unsigned: 无符号的,只能表示正数
            short: 短的,取值范围小,占用内存少
            long: 长的,取值范围大,占用内存多
        一共四个修饰符,前面两个和后面两个组合,把整数分成了六种类型:
            简写                  全写                      含义                字节占用
            short               (signed short int)        短的                byte 2        
            unsigned short      (unsigned short int)      无符号短的            byte 2          
            int                 (signed int)              适中的               byte 4
            unsigned int        (unsigned int)            无符号适中的          byte 4
            long                (signed long int)         长的                 byte 8
            unsigned long       (unsigned long int)       无符号适中的          byte 8
        根据sizeof的内存大小推断它的取值范围:
            一个位的取值是: 0 1                ==>     2¹ - 1 = 1
            两个位的取值是: 00 01 10 11        ==>     2² - 1 = 3
            三个位的取值是: 000 001 ... 111    ==>     2³ - 1 = 7
        公式:
            一个字节有八个位,表示的数据的取值范围是 2⁸-1, 取值范围是255
            如果占用的内存是两个字节,无符号型的取值范围是 2⁸*2⁸-1
            如果占用的内存是四个字节,无符号型的取值范围是 2⁸*2⁸*2⁸*2⁸-1
            如果占用的内存是八个字节,无符号型的取值范围是 2⁸*2⁸*2⁸*2⁸*2⁸*2⁸*2⁸*2⁸-1
            如果是有符号,取值范围减半,因为符号占一个位
        注意:
            long在windows下的字节长度和int一样都是4字节, 在mac和linux下是8字节
                所以根据上面的公式推算,long在不同操作系统下的取值范围是不同的.
            整数的取值范围与计算机操作系统和C++语言编译器有关,没有固定值,可以根据它占用的内存大小来推断它的取值范围
            如果超出取值范围,编译不会报错并且程序能够运行,但是结果是错误的,数据会被截断, 如:
                unsigned short int usi1 = 65535 + 1;        ==>         0
                unsigned short int usi2 = 65535 + 2;        ==>         1
                unsigned short int usi3 = 65535 + 3;        ==>         2
                unsigned short int usi100 = 65535 + 100;    ==>         99
            在实际开发中,为了防止超出取值范围,应该保证有足够的空间.
            C++把整型细分为六种数据类型,目的是为了节省内存空间,但是不能省的就不要省,避免出问题.
        
    整数的书写
        整数默认是十进制,一个表示十进制的数字不需要任何特殊的格式
            但是二进制,八进制和十六进制的数字就不一样,为了和十进制的数字分开,在数字前面加了特定的字符前缀.
        十进制:
            int a = 100;                    ==>         100
        二进制(0b|0B):
            二进制由01两个数字组成,书写时必须以0b或0B(不区分大小写)开头.
                int aa = 0b101;             ==>         5
                int bb = -0b110010;         ==>         -50
                int cc = 0B100001;          ==>         33
        八进制(0):
            八进制由 0~7 八个数字组成, 书写时必须以0开头
            在Linux系统中,设备的权限都是用八进制来表示的.
                int aaa = 015;              ==>         13
                int bbb = -0101;            ==>         -65
                int ccc = 0177777;          ==>         65535
        十六进制(0x|0X):
            十六进制由数字 0~9,字母 A~F或a~f(不区分大小写)组成,书写时必须以0x或0X(不区分大小写)开头.
            在C++中,内存地址缺省用十六进制表示.
                int aaaa = 0x2a;            ==>         42
                int bbbb = -0xa0;           ==>         -160
                int cccc = 0xffff;          ==>         65535
        注意:
            在C++中,不要在十进制的前面加0,会被编译器当成八进制.
            还有不要随便删掉别人代码中整数前面的0,C++程序中的任何一个0都不会是多余的.
    
    long-long类型
        在VS中, long是4字节, 32位, 取值范围:-2147483648~2147483647
        在Liunx中, long是8字节, 64位, 取值范围:-9223372036854775808~9223372036854775807
        C++11增加了 long long 类型的整数, 至少64位, 且至少与long一样长.
        在VS中，long long是8字节，64位, 取值范围: -9223372036854775808~9223372036854775807
        在Linux中，long和long long类型都是8字节，64位。
        
    浮点型
        浮点数也成为实数型
        C++浮点型分三种, float(单精度), double(双精度), long double(扩展精度)
        三者的区别是表示有效数字的范围不同:
            float           byte 4          7位有效数字
            double          byte 8          15~16位有效数字
            long double     不小于double     不低于double
        注意：
            在VS和Linux中，long double占用的内存空间分别是8和16字节。
            有效数字包括了小数点前面和后面的数字。
            C++缺省显示6位有效数字，如果要显示更多的有效数字，可以用printf()函数。
            在实际开发中，用整数代替浮点数，整数的运算更快，精度更高。
            在VS中如果书写一个小数, 默认会将该小数当作double类型, 所以如果要声明为float 需要在小数后面加上f表示float.
                如: float x = 123.456789f;
                
    字符型的基本概念
        字符甚至可以理解为和整数是同一种东西.
        字符型(char)占用的内存空间是1字节, 书写用单引号包含.
        在内存中, 不用存放字符本身, 而是存放它对应的编码, 即ASCII码.
        ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）
        是现今最通用的单字节编码方案，包含了33个控制字符（具有特殊含义无法显示的字符）和95个可显示字符。
            'X'     -> 88   01011000
            'a'     -> 97   01100001
            '3'     -> 51   00110011
        概念:
            a）字符的本质是整数，取值范围是0～127。
            b）在书写的时候可以用单引号包含，也可以用整数。
            c）如果书写的时候用单引号包含，程序执行的时候，将把符号解释为对应的整数。
            d）显示的时候，把整数解释为对应的符号，也可以直接显示整数。
            d）可以与整数进行任何运算，运算的时候，书写方式可以用字符，也可以用整数。
            e）C++为什么没有提供1字节的整型？
    
    转义字符
        常用的转义字符:
            0           \0                  NULL,空,给字符型变量赋值可以直接书写0
            10          \n                  换行(LF),将当前位置移到下一行开头
            13          \r                  回车(CR),将当前位置移到本行开头
            9           \t                  水平制表(HT),跳到下一个TAB位置
            11          \v                  垂直制表(VT),跳到下一个TAB位置
            92          \\                  斜线
            
    Cpp11原始字面量
        原始字面量可以直接表示字符串的实际含义, 不需要转移和连接.
        如:
    
    字符串型
        C++风格字符串:   string 变量名 = "字符串内容"
        C风格字符串:     char 变量名[] = "字符串内容"
        C风格字符串的本质是字符数组，C++风格字符串的本质是类，它封装了C风格字符串。
        Cpp风格字符串的常用操作: 赋值, 拼接.
        注意:
            如果字符串的内容都是常量,就不能进行拼接,否则会报错.
                如: string str = "111"+"222"+"333";
            如果内容很长,cpp中还可以分为多行书写.
                如: string str = "111""222""333";
    
    布尔型
        在C和C++中，关系运算和逻辑运算的结果有两种：真和假。
        C语言用0表示假，非0表示真。
        为了提高代码的可读性，C++新增了 bool 类型，占用1字节的内存，用true表示真，false表示假。
        bool类型本质上是1字节的整数（unsigned char），取值只有1和0。
        在程序中，书写的时候可以用true和false，编译器把它们解释为1和0。
        如果对bool型变量赋非0的值，将转换成1。
        用cin输入和cout输出的时候，仍是1和0，不会被解释为true和false。
    
    数据类型转换
        计算机进行运算时，要求各操作数的类型具有相同的大小和存储方式。
        在实际开发中，不同类型的数据进行混合运算是基本需求。
        自动类型转换：某些类型的转换编译器可以隐式的进行，不需程序员干预。
            不同数据类型的差别在于取值范围和精度，数据的取值范围越大，精度越高。
            整型从低到高：
                char -> short -> int -> long -> long long
            浮点型从低到高：
                float -> double -> long double
            自动类型转换的规则如下：
                如果一个表达式中出现了不同类型操作数的混合运算，较低类型将自动向较高类型转换。
                当表达式中含有浮点型操作数时，所有操作数都将转换为浮点型。
                赋值运算的右值类型与左值类型不一致时，将右值类型提升/降低为左值类型。
                赋值运算右值超出了左值类型的表示范围，把该右值截断后赋给左值，所得结果可能毫无意义。

        强制类型转换：有些类型的转换需要程序员显式指定。
            为了让程序设计更灵活，转换的目的更清晰，C++提供了强制类型转换的方法，也称之为显式转换。
            强制类型转换的语法：(目标类型)表达式
            注意：
                如果使用强制转换，表示程序员已有明确的目的。
                如果转换的行为不符合理，后果由程序员承担。
                如果采用了强制类型转换，编译的告警信息将不再出现。
                类型转换运算符的优先级比较高，如果没把握就加括号。
        
    数据类型别名
        创建数据类型的别名有两个目的：
            为名称复杂的类型创建别名，方便书写和记忆。
            创建与平台无关的数据类型，提高程序的兼容性。
        语法：
            typedef 原数据类型名 别名;
        C++11还可以用using关键字创建数据类型的别名。
            using 别名=原数据类型名;

    


















    
柒.指针和内存(007PointersAndMemory)
    
    指针的基本概念
        变量是内存变量的简称，在C++中，每定义一个变量，系统就会给变量分配一块内存，内存是有地址的。
        C++用运算符&获取变量在内存中的起始地址。
        语法：&变量名
        注意:
            cout输出某些类型时会有bug,显示地址时,会当作字符串显示.
                解决:将地址强转为 void*
                    (void*)&a
                解决:将地址强转为 int
                    (long long)&a
                    因为整数只有是个字节,容纳不下地址,所以要用long long.
            指针默认是用十六进制表示的,不过为了方便我们都用 long long 转为十进制.
        指针变量
            指针变量简称指针，它是一种特殊的变量，专用于存放变量在内存中的起始地址。
            语法：数据类型 *变量名;
            数据类型必须是合法的C++数据类型（int、char、double或其它自定义的数据类型）。
            星号*与乘法中使用的星号是相同的，但是，在这个场景中，星号用于表示这个变量是指针。
        对指针赋值
            不管是整型、浮点型、字符型，还是其它的数据类型的变量，它的地址都是一个十六进制数。
            指针也是有类型的,所以声明指针时需要指定数据类型,不同的类型的指针是有区别的.
            我们用整型指针存放整数型变量的地址；用字符型指针存放字符型变量的地址；
            用浮点型指针存放浮点型变量的地址，用自定义数据类型指针存放自定义数据类型变量的地址等...
            注意
                对指针的赋值操作也通俗的被称为“指向某变量”，被指向的变量的数据类型称为“基类型”。
                    如: int *pa = &a;
                    可以解释为: 让指针pa 指向变量a, 指针的基类型是 int.
                如果指针的数据类型与基类型不符，编译会出现警告。但是，可以强制转换它们的类型。
                    如: int *pa = (int*)&b
        指针占用的内存
            指针也是变量，是变量就要占用内存空间。
            在64位的操作系统中，不管是什么类型的指针，占用的内存都是8字节, 32位系统是4字节.
            在C++中，指针是复合数据类型，复合数据类型是指基于其它类型而定义的数据类型，在程序中，int是整型类型，int*是整型指针类型，int*可以用于声明变量，可以用于sizeof运算符，可以用于数据类型的强制转换，总的来说，把int*当成一种数据类型就是了。
        总结:
            和 golang 一样
            &用于取变量的内存地址, 称为引用运算符 或 地址运算符
            *用于声明指针 和 根据地址取值, 称为间接值 或 解引用运算符
    
    使用指针
        声明指针变量后，在没有赋值之前，里面是乱七八糟的值，这时候不能使用指针。
        指针存放变量的地址，因此，指针名表示的是地址（就像变量名可以表示变量的值一样）
        *运算符被称为间接值或解除引用（解引用）运算符，将它用于指针，可以得到该地址的内存中存储的值.
        *也是乘法符号，C++根据上下文来确定所指的是乘法还是解引用。
        对变量赋初始值是一个好习惯, 一般在定义完之后就应该要赋初始值.
    
    指针用于函数的参数
        如果把函数的形参声明为指针，调用的时候把实参的地址传进去，形参中存放的是实参的地址，在函数中通过解引用的方法直接操作内存中的数据，可以修改实数的值，这种方法被通俗的称为地址传递或传地址。
        值传递：
            函数的形参是普通变量,那么在函数中操作形参不会对实参产生影响.因为值传递是对实参的拷贝.
        地址传递的意义：
            可以在函数中修改实参的值。
                因为cpp中的函数只能有一个返回值, 所以在实际开发中对修改函数中实参值的应用场景非常多
                可以通过函数参数的地址传递对实参进行修改,从而达到类似多个返回值的功能,如(func2)
            减少内存拷贝，提升性能。
                解释:
                    如果用指针变量:
                        int* no = &a2;              int*        内存占用    8字节
                        string* msg = &messages;    string*     内存占用    8字节
                    如果用普通变量:
                        int no = a2;                int         内存占用    4字节
                        string msg = messages;      string      内存占用    40字节
                    so,明白了吧, 普通变量的内存开销是44字节, 而指针的内存开销占用只有16字节
                    即减少了内存的开销或占用, 以提升性能.
    
    用const修饰指针
        常量指针(用的比较多)
            语法：const 数据类型 *变量名;
            不能通过解引用的方法修改内存地址中的值（用原始的变量名是可以修改的）。
            注意：
                指向的变量（对象）可以改变（之前是指向变量a的，后来可以改为指向变量b）。
                一般用于修饰函数的形参，表示不希望在函数里修改内存地址中的值。
                如果用于形参，虽然指向的对象可以改变，但这么做没有任何意义。
                如果形参的值不需要改变，建议加上const修饰，程序可读性更好。
        指针常量
            语法：数据类型* const 变量名;
            指向的变量（对象）不可改变。
            注意：
                在定义的同时必须初始化，否则没有意义。
                可以通过解引用的方法修改内存地址中的值。
                C++编译器把指针常量做了一些特别的处理，改头换面之后，有一个新的名字，叫引用。
        常指针常量
            语法：const 数据类型 * const 变量名;
            指向的变量（对象）不可改变，不能通过解引用的方法修改内存地址中的值。
        总结:
            常量指针：指针指向可以改，指针指向的值不可以更改。
            指针常量：指针指向不可以改，指针指向的值可以更改。
            常指针常量：指针指向不可以改，指针指向的值不可以更改。
    
    void关键字
        在C++中，void表示为无类型，主要有三个用途：
            函数的返回值用void，表示函数没有返回值。
                void func(int a,int b)
                {
                    // 函数体代码。
                    return;
                }
            函数的参数填void，表示函数不需要参数（或者让参数列表空着）。
                int func(void)
                {
                    // 函数体代码。
                    return 0;
                }
            函数的形参用void*，表示接受任意数据类型的指针。
                不能用void声明变量，它不能代表一个真实的变量，但是，用void *可以。
                不能对void *指针直接解引用（需要转换成其它类型的指针）。
                把其它类型的指针赋值给void*指针不需要转换。
                把void *指针赋值给把其它类型的指针需要转换。
    
    Cpp内存模型
        在 C++ 中，程序运行时，内存主要分成四个区，分别是栈、堆、数据段和代码段。
            栈：存储局部变量、函数参数和返回值。
            堆：存储动态开辟内存的变量。
            数据段：存储全局变量和静态变量。
            代码段：存储可执行程序的代码和常量（例如字符常量），此存储区不可修改。
        栈和堆的主要区别：
            1）管理方式不同：栈是系统自动管理的，在出作用域时，将自动被释放；堆需手动释放，若程序中不释放，程序结束时由操作系统回收。
            2）空间大小不同：堆内存的大小受限于物理内存空间；而栈就小得可怜，一般只有8M（可以修改系统参数)。
            3）分配方式不同：堆是动态分配；栈有静态分配和动态分配（都是自动释放）。
            4）分配效率不同：栈是系统提供的数据结构，计算机在底层提供了对栈的支持，进栈和出栈有专门的指令，效率比较高；堆是由C++函数库提供的。
            5）是否产生碎片：对于栈来说，进栈和出栈都有着严格的顺序（先进后出），不会产生碎片；而堆频繁的分配和释放，会造成内存空间的不连续，容易产生碎片，太多的碎片会导致性能的下降。
            6）增长方向不同：栈向下增长，以降序分配内存地址；堆向上增长，以升序分配内存地址。

    动态分配内存new和delete
        使用堆区的内存有四个步骤：
            1）声明一个指针；
            2）用new运算符向系统申请一块内存，让指针指向这块内存；
            3）通过对指针解引用的方法，像使用变量一样使用这块内存；
            4）如果这块内存不用了，用delete运算符释放它。
        申请内存的语法：new 数据类型(初始值);
            如果申请成功，返回一个地址；如果申请失败，返回一个空地址,如果是C++11标准语法还可以: new 数据类型{初始值}.
        释放内存的语法：delete 地址;
            释放内存不会失败。
        注意：
            动态分配出来的内存没有变量名，只能通过指向它的指针来操作内存中的数据。
            如果动态分配的内存不用了，必须用delete释放它，否则有可能用尽系统的内存(重要)。
            动态分配的内存生命周期与程序相同，程序退出时，如果没有释放，系统将自动回收。
            就算指针的作用域已失效，所指向的内存也不会释放。
            用指针跟踪已分配的内存时，不能跟丢。
        
    二级指针
        指针是指针变量的简称，也是变量，是变量就有地址。
        指针用于存放普通变量的地址。
        二级指针用于存放指针变量的地址。
        声明二级指针的语法：数据类型** 指针名;
        使用指针有两个目的：
            传递地址；
            存放动态分配的内存的地址。
        在函数中，如果传递普通变量的地址，形参用指针；传递指针的地址，形参用二级指针。
        把普通变量的地址传入函数后可以在函数中修改变量的值；把指针的地址传入函数后可以在函数中修改指针的值.
        
    空指针
        在C和C++中，用0或NULL都可以表示空指针,声明指针后，在赋值之前，让它指向空，表示没有指向任何地址。
        使用空指针的后果
            如果对空指针解引用，程序会崩溃。
            如果对空指针使用delete运算符，系统将忽略该操作，不会出现异常。所以，内存被释放后，也应该把指针指向空。
            在函数中，应该有判断形参是否为空指针的代码，目的是保证程序的健壮性。
        C++11的nullptr
            用0和NULL表示空指针会产生歧义，C++11建议用nullptr表示空指针，也就是(void *)0。
            NULL在C++中就是0，这是因为在C++中void* 类型是不允许隐式转换成其他类型的，所以之前C++中用0来代表空指针，但是在重载整形的情况下，会出现上述的问题。所以，C++11加入了nullptr，可以保证在任何情况下都代表空指针，而不会出现上述的情况，因此，建议用nullptr替代NULL吧，而NULL就当做0使用。
            注意：在Linux平台下，如果使用nullptr，编译需要加-std=c++11参数。
            
    野指针
        野指针就是指针指向的不是一个有效（合法）的地址。
        在程序中，如果访问野指针，可能会造成程序的崩溃。
        出现野指针的情况主要有三种：
            1）指针在定义的时候，如果没有进行初始化，它的值是不确定的（乱指一气）。
            2）如果用指针指向了动态分配的内存，内存被释放后，指针不会置空，但是，指向的地址已失效。
            3）指针指向的变量已超越变量的作用域（变量的内存空间已被系统回收),把指针指向了函数的局部变量，或者把函数的局部变量的地址作为返回值赋给了指针,会发生该情况.
        规避方法：
            1）指针在定义的时候，如果没地方指，就初始化为nullptr。
            2）动态分配的内存被释放后，将其置为nullptr。
            3）函数不要返回局部变量的地址。
            4) 使用智能指针
        注意：野指针的危害比空指针要大很多，在程序中，如果访问野指针，可能会造成程序的崩溃。是可能，不是一定，程序的表现是不稳定，增加了调试程序的难度。
        
    函数指针和回调函数
        函数的二进制代码存放在内存四区中的代码段，函数的地址是它在内存中的起始地址。如果把函数的地址作为参数传递给函数，就可以在函数中灵活的调用其它函数。
        使用函数指针的三个步骤：
            a）声明函数指针；
                声明普通指针时，必须提供指针的类型。同样，声明函数指针时，也必须提供函数类型，函数的类型是指返回值和参数列表（函数名和形参名不是）
                假设函数的原型是：
                    int func1(int bh,string str);
                    int func2(int no,string message);
                    int func3(int id,string info);

                    bool func4(int id,string info);

                    bool func5(int id);
                则函数指针的声明是：
                    int  (*pfa)(int,string);

                    bool (*pfb)(int,string);

                    bool (*pfc)(int);
                pfa、pfb、pfc是函数指针名，必须用括号，否则就成了返回指针的函数。
            b）让函数指针指向函数的地址；
                函数名就是函数的地址。
                函数指针的赋值：函数指针名=函数名;
            c）通过函数指针调用函数。
                c语法:
                    (*函数指针名)(实参);
                cpp语法:
                    函数指针名(实参);
        















捌.数组(008Array)
    
    数组的基本概念
        数组是一组数据类型相同的变量，可以存放一组数据。
        创建数组
            语法：数据类型 数组名[数组长度];
            注意：
                数组长度必须是整数，可以是常量，也可以是变量和表达式。
                C90规定必须用常量表达式指明数组的大小，C99允许使用整型非常量表达式。
                经测试，在VS中可以用用整型非常量表达式，不能用变量；但是，Linux中还可以用变量。
        数组的使用
            可以通过下标访问数组中元素，数组下标从0开始。
            语法：数组名[数组下标]
            注意：
                数组下标也必须是整数，可以是常量，也可以是变量。
                合法的数组下标取值是：0~(数组长度-1)。
        数组占用内存的情况
            数组在内存中占用的空间是连续的。
            用sizeof(数组名)可以得到整个数组占用内存空间的大小（只适用于C++基本数据类型）。
        数组的初始化
            声明的时候初始化：
                数据类型 数组名[数组长度] = { 值1，值2，值3, ...... , 值n};
                数据类型 数组名[ ] = { 值1，值2，值3, ...... , 值n};
                数据类型 数组名[数组长度] = { 0 };  // 把全部的元素初始化为0。
                数据类型 数组名[数组长度] = { };    // 把全部的元素初始化为0。
            注意：
                如果{}内不足数组长度个数据，剩余数据用0补全，但是，不建议这么用，你可能在数组中漏了某个值。
                如果想把数组中全部的元素初始化为0，可以在{}内只填一个0或什么也不填。
                C++11标准可以不写等于号。
        清空数组
            用memset()函数可以把数组中全部的元素清零。（只适用于C++基本数据类型）
            函数原型：void *memset(void *s, int c, size_t n);
            注意，在Linux下，使用memcpy()函数需要包含头文件#include <string.h>
        复制数组
            用memcpy()函数可以把数组中全部的元素复制到另一个相同大小的数组。（只适用于C++基本数据类型）
            函数原型：void *memcpy(void *dest, const void *src, size_t n);
            注意，在Linux下，使用memcpy()函数需要包含头文件#include <string.h>
    
    数组和指针
        指针的算术
            将一个整型变量加1后，其值将增加1。
            但是，将指针变量（地址的值）加1后，增加的量等于它指向的数据类型的字节数。
        数组的地址
            a）数组在内存中占用的空间是连续的。
            b）C++将数组名解释为数组第0个元素的地址。
            c）数组第0个元素的地址和数组首地址的取值是相同的。
            d）数组第n个元素的地址是：数组首地址+n
            e）C++编译器把   数组名[下标]  解释为  *(数组首地址+下标)
        数组的本质
            数组是占用连续空间的一块内存，数组名被解释为数组第0个元素的地址。
            C++操作这块内存有两种方法：数组解释法和指针表示法，它们是等价的。
        数组名不一定会被解释为地址
            在多数情况下，C++将数组名解释为数组的第0个元素的地址，但是，将sizeof运算符用于数据名时，将返回整个数组占用内存空间的字节数,所以数组名并不是的地址.
            可以修改指针的值，但数组名是常量，不可修改。
            
    数组的越界
        数组越界在windows下是会报错且终止程序运行的,但是在linux下所有越界的值都将赋为0.
        数组越界就是一种野指针, 所以开发时需要注意, 这种低级错误不要犯.
            int arr6[5] = {0,1,2,3,4};
            for (int i = 0; i < 8; i++) {
                arr6[i] = i + 100;
                cout << "arr6[ + " << i << "]的值是 = " << (long long)arr6[i] << endl;
            };
    
    数组用于函数的参数
        1）指针的数组表示
            在C++内部，用指针来处理数组。
            1) C++编译器把   数组名[下标]  解释为  *(数组首地址+下标)
            2) C++编译器把   地址[下标]  解释为  *(地址+下标)
        2）一维数组用于函数的参数
            一维数组用于函数的参数时，只能传数组的地址，并且必须把数组长度也传进去，除非数组中有最后一个元素的标志。
            书写方法有两种： 
                void func(int* arr, int len);
                void func(int arr[], int len);
            注意：
                在函数中，可以用数组表示法，也可以用指针表示法。
                在函数中，不要对指针名用sizeof运算符,它不是数组名,
                    因为sizeof(数组名)得到的是数组的内存大小,如func();
                    而sizeof(指针名)得到的永远都是8字节,这就是为什么要把数组长度计算好再传进来的原因了
        
    用new动态创建数组
        普通数组在栈上分配内存，栈很小；如果需要存放更多的元素，必须在堆上分配内存。
        动态创建一维数组的语法：
            数据类型 *指针=new 数据类型[数组长度];
        释放一维数组的语法：
            delete [] 指针;
        注意：
            动态创建的数组没有数组名，不能用sizeof运算符。
            可以用数组表示法和指针表示法两种方式使用动态创建的数组。
            必须使用delete[]来释放动态数组的内存（不能只用delete）。
            不要用delete[]来释放不是new[]分配的内存。
            不要用delete[]释放同一个内存块两次（否则等同于操作野指针）。
            对空指针用delete[]是安全的（释放内存后，应该把指针置空nullptr）。
            声明普通数组的时候，数组长度可以用变量，相当于在栈上动态创建数组，并且不需要释放。
            如果内存不足，调用new会产生异常，导致程序中止；如果在new关键字后面加(std::nothrow)选项，则返回nullptr，不会产生异常。
            为什么用delete[]释放数组的时候，不需要指定数组的大小？因为系统会自动跟踪已分配数组的内存。
            
    数组排序
        qsort()函数用于对各种数据类型的数组进行排序。
        函数的原型：
            void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
            第一个参数：数组的起始地址(数组名)
            第二个参数：数组元素的个数（数组长度）。
            第三个参数：数组元素的大小（sizeof(数组的数据类型)）。
            第四个参数：回调函数的地址。
            回调函数决定了排序的顺序，声明如下：    
                int compar(const void *p1, const void *p2);
                1）如果函数的返回值< 0 ，那么p1所指向元素会被排在p2所指向元素的前面。
                2）如果函数的返回值==0，那么p1所指向元素与p2所指向元素的顺序不确定。
                3）如果函数的返回值> 0 ，那么p1所指向元素会被排在p2所指向元素的后面。
                
                void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
        qsort()函数的其它细节：
            形参中的地址用void是为了支持任意数据类型，在回调函数中必须具体化。
            为什么需要第三个形参size_t size？
            size_t是C标准库中定义的，在64位系统中是8字节无符号整型（unsigned long long）typedef unsigned long long size_t
            排序的需求除了升序和降序，还有很多不可预知的情况，只能用回调函数。
        
    数组查找
        折半查找也叫二分查找，只适用于已排序的数组（升序降序都可以）。
        
    C字符串
        cpp中的string使用方便,能自动扩展,无需担心内存问题,string是cpp的类,是对C中字符串的封装
        但在某些应用场景中,C字符串更方便和高效.
        C语言约定：如果字符型（char）数组的末尾包含了空字符\0（也就是0），那么该数组中的内容就是一个字符串。
        因为字符串需要用0结尾，所以在声明字符数组的时候，要预留多一个字节用来存放0。
        声明一个最多存放20个英文字符或十个中文的字符串。
            char name[21];
        初始方法:
            char str2[11] = "hello";
            char str3[] = {"hello"};
            char str4[11] = {"hello"};
            char str5[11]{"hello"};
            char str6[11] = {0}
                把全部元素初始化为0,相当于清空字符串的意思
        清空字符串:
            memset(name,0,sizeof(name));
                把全部的元素置为0:
            str[0]=0;
                C约定了用0表示字符串的结束,那么第一个元素置为0,那么后面的任何值都没有意义了(不规范,有隐患,不推荐)
        字符串复制或赋值(strcpy)
            cpp字符串可以字节用等号赋值,但是c字符串不可以,要用strcpy函数实现赋值.
            char *strcpy(char* dest, const char* src);
            参数: 目标字符串,源字符串
            功 能: 将参数src字符串拷贝至参数dest所指的地址。
            返回值: 返回参数dest的字符串起始地址。
            复制完字符串后，会在dest后追加0。
            如果参数dest所指的内存空间不够大，会导致数组的越界。
        字符串复制或赋值(strncpy)
            char * strncpy(char* dest,const char* src, const size_t n);
            功能：把src前n个字符的内容复制到dest中。
            返回值：dest字符串起始地址。
            如果src字符串长度小于n，则拷贝完字符串后，在dest后追加0，直到n个。
            如果src的长度大于等于n，就截取src的前n个字符，不会在dest后追加0。
            如果参数dest所指的内存空间不够大，会导致数组的越界。
            strncpy的坑点:
                strncpy(str8, "hello", 3);
                hello是五个字符,但是只有3个值,windows平台下会将其他值赋为垃圾值.
                解决这个问题就是在strncpy之前,用memset将字符数组清空:memset(str8, 0, sizeof(str8));
        获取字符串的长度(strlen)
            size_t  strlen( const char*  str);
            功能：计算字符串的有效长度，不包含0。
            返回值：返回字符串的字符数。
            strlen()函数计算的是字符串的实际长度，遇到0结束。
        字符串拼接(strcat)
            char *strcat(char* dest,const char* src);
            功能：将src字符串拼接到dest所指的字符串尾部。
            返回值：返回dest字符串起始地址。
            dest最后原有的结尾字符0会被覆盖掉，并在连接后的字符串的尾部再增加一个0。
            如果参数dest所指的内存空间不够大，会导致数组的越界。
        字符串拼接(strncat)
            char *strncat (char* dest,const char* src, const size_t n);
            功能：将src字符串的前n个字符拼接到dest所指的字符串尾部。
            返回值：返回dest字符串的起始地址。
            如果n大于等于字符串src的长度，那么将src全部追加到dest的尾部，如果n小于字符串src的长度，只追加src的前n个字符。
            strncat会将dest字符串最后的0覆盖掉，字符追加完成后，再追加0。
            如果参数dest所指的内存空间不够大，会导致数组的越界。
        字符串比较strcmp()和strncmp()
            int strcmp(const char *str1, const char *str2 );
            功能：比较str1和str2的大小。
            返回值：相等返回0，str1大于str2返回1，str1小于str2返回-1；
            int strncmp(const char *str1,const char *str2 ,const size_t n);
            功能：比较str1和str2前n个字符的大小。
            返回值：相等返回0，str1大于str2返回1，str1小于str2返回-1；
            两个字符串比较的方法是比较字符的ASCII码的大小，从两个字符串的第一个字符开始，如果分不出大小，就比较第二个字符，如果全部的字符都分不出大小，就返回0，表示两个字符串相等。
            在实际开发中，程序员一般只关心字符串是否相等，不关心哪个字符串更大或更小。
        查找字符strchr()和strrchr()
            const char *strchr(const char *s, int c);
            返回在字符串s中第一次出现c的位置，如果找不到，返回0。
            const char *strrchr(const char *s, int c);
            返回在字符串s中最后一次出现c的位置，如果找不到，返回0。
        查找字符串strstr()
            char *strstr(const char* str,const char* substr);
            功能：检索子串在字符串中首次出现的位置。
            返回值：返回字符串str中第一次出现子串substr的地址；如果没有检索到子串，则返回0。
        用于string的表达式
            可以把C风格的字符串用于包含了string类型的赋值拼接等表达式中。
        注意事项
            a）字符串的结尾标志是0，按照约定，在处理字符串的时候，会从起始位置开始搜索0，一直找下去，找到为止（不会判断数组是否越界）。
            b）结尾标志0后面的都是垃圾内容。
            c）字符串在每次使用前都要初始化，减少入坑的可能，是每次，不是第一次。
            d）不要在子函数中对字符指针用sizeof运算，所以，不能在子函数中对传入的字符串进行初始化，除非字符串的长度也作为参数传入到了子函数中。
            e）windoes平台中，默认C标准的字符串操作函数是不安全的，如果要使用C标准的字符串操作函数，要在源代码文件的最上面加 #define _CRT_SECURE_NO_WARNINGS，还可以通过 strcpy_s，strcat_s ... 等函数处理字符串函数操作的安全性问题,一般在linux平台下是不会有这些问题的,所以了解下即可.
    
    二维数组
        一维数组的数学概念是线性表，二维数组的数学概念是矩阵。
        创建二维数组
            声明二维数组的语法：数据类型 数组名[行数][列数];
            注意：数组长度必须是整数，可以是常量，也可以是变量和表达式。
            C90规定必须用常量表达式指明数组的大小，C99允许使用整型非常量表达式。经测试，在VS中可以用用整型非常量表达式，不能用变量；但是，Linux中还可以用变量。
        二维数组的使用
            可以通过行下标和列下标访问二维数组中元素，下标从0开始。
            二维数组中每个元素的特征和使用方法与单个变量完全相同。
            语法：数组名[行下标][列下标]
            注意：
            二维数组下标也必须是整数，可以是常量，也可以是变量。
            合法的行下标取值是：0~(行数-1)。
            合法的列下标取值是：0~(列数-1)。
        二维数组占用内存的情况
            用sizeof(数组名)可以得到整个二维数组占用内存空间的大小（只适用于C++基本数据类型）。
            二维数组在内存中占用的空间是连续的。
            二维数组的数组名也被解释为起始地址,和一维数组是一样的,用一维数组的方法可以正常显示而为数组的内容
        二维数组的初始化
            声明的时候初始化：
            数据类型 数组名[行数][列数] = { {数据1，数据2 } ，{数据3，数据4 },...... };
            数据类型 数组名[行数][列数] = { 数据1，数据2，数据3，数据4, ......};
            数据类型 数组名[ ][列数] = { 数据1，数据2，数据3，数据4,......};
            数据类型 数组名[行数][列数] = { 0 };  // 把全部的元素初始化为0。
            数据类型 数组名[行数][列数] = { };    // 把全部的元素初始化为0。
            注意：
                如果{}内不足数组长度个数据，剩余数据用0补全，但是，不建议这么用，你可能在数组中漏了某个值。如果想把数组中全部的元素初始化为0，可以在{}内只填一个0或什么也不填。
            C++11标准可以不写等于号。
        清空二维数组
            用memset()函数可以把二维数组中全部的元素清零。（只适用于C++基本数据类型）
            函数原型：void *memset(void *s, int c, size_t n);
            注意，在Linux下，使用memcpy()函数需要包含头文件#include <string.h>
        复制二维数组
            用memcpy()函数可以把二维数组中全部的元素复制到另一个相同大小的数组（没说多少维）。（只适用于C++基本数据类型）
            函数原型：void *memcpy(void *dest, const void *src, size_t n);
            注意，在Linux下，使用memcpy()函数需要包含头文件#include <string.h>
    
    二维数组用于函数的参数
        指针复习:
            整型指针。
                int* p;
            一维整型指针数组，元素是3个整型指针（p[0]、p[1]、p[2]）。   
                int* p[3];
            函数p的返回值类型是整型的地址。
                int* p(); 
            p是函数指针，函数的返回值是整型。
                int (*p)(int ,int);
        概念:
            地址是地址,指针是指针,不要把地址说成指针,指针是一个容器,是用于存放地址的.
        行指针(数组指针):
            声明行指针的语法：数据类型 (*行指针名)[行的大小];  // 行的大小即数组长度。
            int (*p1)[3];  // p1是行指针，用于指向数组长度为3的int型数组。
            int (*p2)[5];  // p2行指针，用于指向数组长度为5的int型数组。
            double (*p3)[5];  // p3是行指针，用于指向数组长度为5的double型数组。
            一维数组名被解释为数组第0个元素的地址。
            对一维数组名取地址得到的是数组的地址，是行地址。
        二维数组名是行地址
            int bh[2][3] = { {11,12,13},{21,22,23} };
            bh是二维数组名，该数组有2两元素，每一个元素本身又是一个数组长度为3的整型数组。
            bh被解释为数组长度为3的整型数组类型的行地址。
            如果存放bh的值，要用数组长度为3的整型数组类型的行指针。
            int (*p)[3]=bh;

            int bh[4][2][3];
            bh是三维数组名，该数组有4元素，每一个元素本身又是一个2行3列的二维数组。
            bh被解释为2行3列的二维数组类型的二维地址。
            如果存放bh的值，要用2行3列的二维数组类型的二维指针。
            int (*p)[2][3]=bh;
        把二维数组传递给函数
            如果要把bh传给函数，函数的声明如下：
            void func(int (*p)[3],int len);
            void func(int p[][3],int len);
        
        ... TODO ...
        
        
        
        
        
        
        
        
                
        
        
        
        
        
        
        
        
        
        
                
        
        
        
        
        
        
        
        
        
        
        




零、壹、贰、叁、肆、伍、陆、柒、捌、玖、拾;
